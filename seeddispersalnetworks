/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var humanmod = ee.ImageCollection("CSP/HM/GlobalHumanModification"),
    Ecoregions2017 = ee.FeatureCollection("RESOLVE/ECOREGIONS/2017"),
    networks = ee.FeatureCollection("users/varshavijay101/GEEforSynthesis/networks3");
/***** End of imports. If edited, may not auto-convert in the playground. *****/

////////// Case Study: Human modification and habitat type for//////////// 
//////////////////seed dispersal network samples ////////////////
 /*
 2020 Varsha Vijay GEEforSynthesis 
 https://sites.google.com/view/geeforsynthesis
 
*/

//This case study comes from a collaboration with Dr. Evan Fricke.
//Please read below for background

/*
Dr. Evan Fricke, an ecologist and fellow postdoctoral researcher at SESYNC, 
is trying to understand mutualistic plant-animal interactions 
through the study of seed dispersal networks. 
Using a new dataset composed of network observations around the world,
he wants to answer questions both about the broad ecological patterns of these networks
and the role that humans have in altering native interactions through
the introduction of native species.

Cool stuff!
*/

/*
To better characterize anthropogenic impacts in locations with
network observations, he wanted to use the Global Human Modification dataset.
Please search the bar above to learn more about this dataset.

I developed this code in GEE, because it takes advantage of 
some of the unique resources of this environment.
* Dataset is in the GEE data catalog
* GEE allows for to rapid calculation of statistics on image regions
*/

/*
Add Global Human Modification (gHM) dataset to code editor
print dataset
*/

/*
For our analysis we want to use the gHM data as an image
not an image collection. To do this we need to extract the single
image from the image collection.
This can be done by calling the image directly using the
Image id found when printing the collection like below
*/

//var name= ee.Image('imageid')

/*
or by selecting the first image in this image collection
or be filtering the image collection as shown in the previous collection.
Select the image using the first() function
*Note that we explicitly cast to an Image object type
when using these approaches*
*/

//var name=ee.Image(name.first())

/*
Comment out one of these approaches to get your final image and print
to verify object type and properties.
*/

/*
Great job!
Now visualize the gHM to understand the data better
using the visualization parameters provided below
Modify the visualiztion using the palette argument with 
either color names or hex colors
Use the appropriate Map. function
*/

//var vizparams= {min:0,max:1,palette: ['0000FF','FFFF00','FF0000']}//blue,yellow,red

/*
Because we are doing calculations for sample regions
we need to understand the spatial resolution of these data
Try this for the gHM data by modifying the code below
*/

//print(name.projection().nominalScale())

/*
This nominal scale is in agreement with the metadata
spatial resolution is nominal 1km
*/

/*
Now import the network sample locations from the Resources
page of the workshop website. The csv file is called
GEEforSynthesisNETWORKS. *Note this is a subset of of the original data
Import as csv and add to code editor. Cast object to FeatureCollection
*/

var networks= ee.FeatureCollection(networks)

/*
See how many network sample locations are in the dataset
using the size() function and print to view data properties
*/

print(networks)

//Add networks to Map
Map.centerObject(networks)
Map.addLayer(networks,{},'networks')//,
//Get human mod index for all sites
var networkmod= ghm.reduceRegions({
  collection: networks,
  reducer: ee.Reducer.mean(),//.unweighted(),
  scale:ghm.projection().nominalScale()
  })
//Check image reduction
//print(ghm.bandNames())
//print(networkmod.limit(2))//.select(ghm.bandNames()))
//Export table to V's drive
Export.table.toDrive({
  collection: networkmod,
  description: 'networkmodpt',
  folder: 'Evan',
  fileFormat:'CSV'
});

//Filter Islands


//Buffer sample network locations

var applybuff = function(feature) {
  return feature.buffer(5000);  
};

var networkbuff = networks.map(applybuff);
Map.addLayer(networkbuff,{color: '00FF00'},'networkbuff')
//Reduce regions
var networkmodBUFF= ghm.reduceRegions({
  collection: networks,
  reducer: ee.Reducer.mean(),//['meangHM'],//.unweighted(),
  scale:ghm.projection().nominalScale()
  })
//Check
//print(networkmodBUFF.first())

//Export table to V's drive
Export.table.toDrive({
  collection: networkmodBUFF,
  description: 'networkmodbuff',
  folder: 'Evan',
  fileFormat:'CSV'
});

//

///////////////Add Biome/Ecoregion for each sample location
///Load Feature Collection
var ecoregions2017=ee.FeatureCollection(Ecoregions2017)//be explict in object type
Map.addLayer(ecoregions2017,{},'ecoregions2017')
//var biomes2017=ecoregions2017.select('BIOME_NAME')
//var biomes17=ee.FeatureCollection(biomes17)
//print(biomes2017.first())

///Create nested function to iterate and pull biome names from dataset
var networkbiomes = ecoregions2017.map(function(feature){
  feature = ee.Feature(feature);
  var biomename = feature.get('BIOME_NAME');
  var networkfilter = networks.filterBounds(feature.geometry()).map(function(network){
    return ee.Feature(network).set('biome', biomename);
  });
  return networkfilter;
}).flatten();

print(networkbiomes.first())
Map.addLayer(networkbiomes,{},'networkbiomes')

//Export tables
//Export table to V's drive
Export.table.toDrive({
  collection: networkbiomes,
  description: 'networkbiomes',
  folder: 'Evan',
  fileFormat:'CSV'
});

///////Spatial Join code....currently still produces list of list
///////However overall good to know this method because the current one
///////Is error prone in areas near boundaries of biomes/ecoregions
///////multiple biomes will be assigned to a single sample point
///////Intersect/spatial join is the only way to ensure a hard cutoff
/*

// Define a spatial filter, with distance 1 km.
var distFilter = ee.Filter.withinDistance({
  distance: 1000,
  leftField: '.geo',
  rightField: '.geo',
  maxError: 10
});

var intersectfilter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo',
  maxError: 10
});

// Define a saveAll join.
var distSaveAll = ee.Join.saveAll({
  matchesKey: 'biome',
  measureKey: 'distance'
});

var intersectSaveAll= ee.Join.saveAll({
  matchesKey: 'biome'
});


// Apply the join.
var networkbiomejoin = distSaveAll.apply(networks, biomes2017, distFilter);
//print(networkbiomejoin.first())
var networkbiomeintersect=intersectSaveAll.apply(networks,biomes2017,intersectfilter);

/*
///Spatial Join with tolerance
// Add Biome name as a property
var biomenamenetworkjoin = networkbiomejoin.map(function(network) {
  // Get the name of the biome
  var biome = network.get('points');
  // Return the network with a new property for biome name
  return network.set('biome', biome);
});

///Spatial Intersect
// Add Biome name as a property
var biomenamenetworkintersect = networkbiomeintersect.map(function(network) {
  // Get the name of the biome
  var biome = network.get('BIOME_NAME');
  // Return the network with a new property for biome name
  return network.set('biome', biome);
});
*/
////////////////////////////////////////////////////
/*
//Alternate approach to spatial intersection
var networksgetbiomes= networks.map(function(feat){
  feat = ee.Feature(feat);
  return  ee.Feature(feat.geometry().intersection(biomes2017), {}).copyProperties(feat);
});

print(networksgetbiomes.first())

// Print the result.
print(networkbiomejoin.first());

print(networkbiomeintersect.first());

/*
//Map result
Map.addLayer(networkbiomejoin,{},'networkbiomejoin')
Map.addLayer(networkbiomeintersect,{},'networkbiomeintersect')


//Export tables
//Export table to V's drive
Export.table.toDrive({
  collection: networkbiomejoin,
  description: 'networkbiomejoin',
  folder: 'Evan',
  fileFormat:'CSV'
});

//Export table to V's drive
Export.table.toDrive({
  collection: networkbiomeintersect,
  description: 'networkbiomeintersect',
  folder: 'Evan',
  fileFormat:'CSV'
});

*/
