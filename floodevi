/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var modisevi = ee.ImageCollection("Oxford/MAP/EVI_5km_Monthly"),
    hansen = ee.Image("UMD/hansen/global_forest_change_2018_v1_6");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
////////// Influence of Phenology on Runoff Response //////////////////
///////////////////////to Forest Loss //////////////////////////
 /*
 2020 Varsha Vijay GEEforSynthesis 
 https://sites.google.com/view/geeforsynthesis
 
*/

//This case study comes from a collaboration with 
//Dr. James Knighton.
//Please read below for background.

/*
Dr. James Knighton, an environmental engineer and fellow postdoctoral researcher at SESYNC,
is investigating hydrologic responses to forest cover loss. 
One of the questions he has is whether variability in stream gage 
runnoff responses to forest loss can be explained by
phenological patterns (periodic cyling of vegetation). By evaluating this, and other potential
predictors, he hopes to characterize flood risk post-deforestation.

This has implications for the management of these systems as well as determining potential benefits
of reforestation efforts.
*/

/*
Here, we focus on characterizing vegetation phenology using MODIS EVI data.
The approaches used in this analysis combines the approaches used in the previous analysis.
Because of that, this lesson is shorter and is provided as fully functional code, commented
to explain some of the thought process behind the approach used.

Go through the lesson and explore, using visualization and printing where
you need further clarification
*/

//Load stream gage data from forested catchments.  All experienced forest loss during
//the 2001-2018 study period but are assumed to be forested 
//in year 2000
var gagesites=ee.FeatureCollection('users/varshavijay101/GEEforSynthesis/gagesites')
Map.addLayer(gagesites,{},'sites')


/*
We use Oxford MAP EVI, a global, gap filled monthly EVI estimate for 
years 2000 to 2015 to characterize the areas around the stream gage locations.

Start by filtering the image collection to the appropriate band and 
time range (consistent with Hansen Global Forest loss data).

These data are provided at 5km spatial resolution 
*/
var meanevi = modisevi.select('Mean').filterDate('2000-01-01', '2015-12-01');

/*
Apply a minimal buffer to point data to pull pixels around the gage site
*/
var applybuff = function(feature) {
  return feature.buffer(5000);  
};

var sitesbuff = gagesites.map(applybuff);
Map.addLayer(sitesbuff,{color: 'FF0000'},'buffsites')

/*
We begin with a visualization of sample EVI time series on a chart plotting
the first five samples in our dataset which are all located in Brazil.

We will also add these samples to the Map just as a reminder of where they
occur geographically
*/
var sitesfirst5= sitesbuff.limit(5)
Map.centerObject(sitesfirst5)
Map.addLayer(sitesfirst5,{color: '0000FF'},'Brazilsites')
print(ui.Chart.image.seriesByRegion(meanevi, sitesfirst5, ee.Reducer.mean(),'Mean',5000))

/*
There's a lot of years on that chart, making it difficult to understand, so let
us first filter the data to just year 2014
*/
print(ui.Chart.image.seriesByRegion(meanevi.filterDate('2014-01-01', '2015-12-01'), sitesfirst5, ee.Reducer.mean(),'Mean',5000))
print('Brazilsamples',sitesfirst5)

/*
Interestingly within our Brazil samples we different phenology captured by our EVI
time series

To understand these temporal trends in EVI further, we extract time series for all
our sample locations. This becomes a little complicated but is just the extension
of the application of mapped functions we were using before.  In this case we are mapping 
over all the images in the meanevi image collection, and assigning the Mean EVI value for 
that image to the feature (excluding null values). Then we are assigning the image ID
to each feature
*/

var gageevi = meanevi.map(function(image) {
  return image.reduceRegions({
    collection: sitesbuff,
    reducer: ee.Reducer.mean().setOutputs(image.bandNames()),
    scale: 5000,
  })
  .filter(ee.Filter.neq('Mean', null))
 .map(function(feature) {
    return feature.set({
      'ID': image.id(),
    });});
}).flatten();
//print(meanevi.first())
print(gageevi.limit(10))

var nullgeom= function(feature){
  feature = feature.setGeometry(null)
  return (feature)}
  
var gageeviNULL=  gageevi.map(nullgeom)
print(gageeviNULL.first())

Export.table.toDrive({
  collection: gageeviNULL,
  folder:'GEEforSynthesis',
  description: 'evitimeseries',
  fileFormat: 'CSV'
});

/*


///Global mean timing of max evi
var months = ee.List.sequence(1, 12);
var years = ee.List.sequence(2000, 2018);
///refilter collection for ease of code
var meanevi=modisevi
  .filter(ee.Filter.calendarRange(2000,2018,'year'))
  .filter(ee.Filter.calendarRange(1,12,'month'))
  .sort('system:time_start')
  // .filterBounds(ROI)
  .select("Mean")
var add_bands = function(image) {
  image = ee.Image(image);
  return image.addBands(ee.Image.constant(ee.Number.parse(image.date().format("M"))).rename('month').float());
};

var meanevi = meanevi.map(add_bands)
print(meanevi,'meanevi')
var maxmonthbyyear = ee.ImageCollection.fromImages(
      years.map(function (y) {
        return meanevi.filter(ee.Filter.calendarRange(y, y, 'year'))
                    .qualityMosaic('Mean')//.select('month')
                    .set('year', y)
                    //.map(add_bands);
}));
print(maxmonthbyyear);

var maxmonth=maxmonthbyyear.select('month')

var modemaxevimonth=maxmonth.mode()
print(modemaxevimonth)

Map.addLayer(modemaxevimonth)
//print(modemaxevimonth.projection().nominalScale)
//Export global image data
var unboundedGeo = ee.Geometry.Polygon([-180, 88, 0, 88, 180, 88, 180, -88, 0, -88, -180, -88], null, false);

Export.image.toDrive({
  image: modemaxevimonth, 
  description: 'modemaxevimonth',
  region: unboundedGeo,
  //scale: ,
  crs: 'EPSG:4326',
  //crsTransform: [0.0083333333334, 0, -180, 0, -0.0083333333334, 90.00000000144001],
  //dimensions: '43200x21600',
  maxPixels: 1e13
});


//var maxevimonth = meanevi.qualityMosaic('Mean').select('month');
//print(maxevimonth,'max')
/*
var byYear = ee.ImageCollection.fromImages(
  years.map(function(y) {
      return meanevi
        .filter(ee.Filter.neq('Mean', null))
        .filter(ee.Filter.calendarRange(y, y, 'year'))
        .max()
        .set('date', ).set('year', y);
  });
}).flatten());

print(byMonthYear)
print(meanevi)
/*
///////Other data processing...ignore
///Adjust the scale of EVI input data and create monthly composites
var terrevi=ee.ImageCollection(terraevi).select('EVI')
//print(terrevi.first())
var aqevi=ee.ImageCollection(aquaevi).select('EVI')
var months = ee.List.sequence(1, 12);

var compositeterraevi = ee.ImageCollection.fromImages(months.map(function(m) {
  var filtered = terrevi.filter(ee.Filter.calendarRange({
    start: m,
    field: 'month'
  }));
  var median = filtered.ee.Reducer.median();
  return median
      .set('month', m);
}));

//print(compositeterraevi)
*/

/*
In the original analysis the primary deforestation date 
(found in the Forest_Los property of each site) was determined using the total
catchment area, but for the sake of our analysis lets determine the most frequent
deforestation date for pixels within each of our sample regions.
*/

/*
Load Hansen forest loss and extract mean loss year for 
deforested pixels in each sample location
*/
var lossyear=hansen.select('lossyear')
var lossyearmask=lossyear.mask(lossyear.gt(0))
Map.addLayer(lossyearmask)
//Map.addLayer(lossyear,{min:1,max:18},'lossyear')

var sampleloss=lossyearmask
.reduceRegions({
  collection: sitesbuff,
  reducer: ee.Reducer.mode().unweighted(),
  scale: 30,
})

print(sampleloss)

/*
Printing these data show that there is some discrepancy between the value 
determined for the catchment area vs the sample area.  This is probably
fine for the sake of our analysis but its good to keep in mind when we
further process the data.
*/

